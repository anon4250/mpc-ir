#include <algorithm>
#include <chrono>
#include <iostream>
#include <regex>

#include <boost/lexical_cast.hpp>
#include <boost/program_options.hpp>
#include <fmt/format.h>

#include "base/party.h"
#include "communication/communication_layer.h"
#include "communication/tcp_transport.h"
#include "statistics/analysis.h"

#include "collect_stats.h"

#include "{{ header_fname }}"

namespace program_options = boost::program_options;

const std::regex kPartyArgRegex("([01]),([^,]+),(\\d{1,5})");

// We need to implement the below operator to let Boost support default
// values for vectors.
namespace std {
template <typename T>
std::ostream &operator<<(std::ostream &os, const std::vector<T> &vec)
{
    os << "[";
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        if (it != vec.begin()) {
            os << ", ";
        }
        os << *it;
    }
    os << "]";
    return os;
}

std::ostream &operator<<(std::ostream &os, const encrypto::motion::SecureUnsignedInteger &val)
{
    os << val.As<std::uint32_t>();
    return os;
}

std::ostream &operator<<(std::ostream &os, const encrypto::motion::ShareWrapper &val)
{
    if (val.As<bool>() == true) {
        os << "True";
    } else {
        os << "False";
    }
    return os;
}
} // namespace std

program_options::variables_map parse_options(const int argc, const char *const argv[])
{
    bool help;
    // clang-format off
    program_options::options_description description("Allowed options");
    description.add_options()
        ("help,h", program_options::bool_switch(&help)->default_value(false), "produce help message")
        ("my-id", program_options::value<std::size_t>(), "my party id")
        ("parties", program_options::value<std::vector<std::string>>()->multitoken()->default_value(std::vector<std::string>({"0,127.0.0.1,23000", "1,127.0.0.1,23001"})),
          "(party id, host, port, my role), e.g., --parties 0,127.0.0.1,23000 1,127.0.0.1,23001")
        // Autogenerated options for each shared input
        {%- for param in params %}
        ("{{ param.name }}",
         {%- if param.dims == 0 -%}
            program_options::value<std::uint32_t>()
         {%- else -%}
            program_options::value<std::vector<std::uint32_t>>()->multitoken()
         {%- endif -%}
         {%- if param.default_value is not none -%}
             ->default_value({{param.plaintext_cpp_type}}({{ param.default_value|string|replace('[','{')|replace(']','}') }}))
         {%- endif -%}
            , "input for {{ param.name }}")
        {%- endfor %} // clang-format on
    ;

    program_options::variables_map user_options;
    program_options::store(program_options::parse_command_line(argc, argv, description),
                           user_options);
    program_options::notify(user_options);

    if (help) {
        std::cout << description << std::endl;
        return user_options;
    }

    // error checking
    if (user_options.count("my-id") == 0) {
        throw std::runtime_error("my-id is not specified");
    }

    if (user_options.count("parties") == 0) {
        throw std::runtime_error("parties are not specified");
    } else {
        const std::vector<std::string> other_parties{
            user_options["parties"].as<std::vector<std::string>>()};
        if (other_parties.size() != 2)
            throw std::runtime_error(
                fmt::format("Incorrect number of parties {} (expected 2)", other_parties.size()));
        std::string parties("Other parties: ");
        for (auto &party : other_parties) {
            if (!std::regex_match(party, kPartyArgRegex)) {
                throw std::runtime_error(
                    fmt::format("Incorrect party argument syntax for party {}", party));
            }
        }
    }

    return user_options;
}

encrypto::motion::PartyPointer CreateParty(const program_options::variables_map &opts)
{
    const auto parties_strings = opts["parties"].as<std::vector<std::string>>();
    const auto my_id = opts["my-id"].as<std::size_t>();
    if (my_id >= parties_strings.size()) {
        throw std::runtime_error(fmt::format("my-id {} is out of range (must be between 0 and {})",
                                             my_id, parties_strings.size() - 1));
    }

    encrypto::motion::communication::TcpPartiesConfiguration parties_configuration(
        parties_strings.size());

    for (const auto &party_string : parties_strings) {
        std::smatch match;
        std::regex_match(party_string, match, kPartyArgRegex);
        const auto party_id = boost::lexical_cast<std::size_t>(match[1]);
        const auto host = match[2];
        const auto port = boost::lexical_cast<std::uint16_t>(match[3]);

        if (party_id >= parties_strings.size()) {
            throw std::runtime_error(
                fmt::format("party_id {} is out of range (must be between 0 and {})", party_id,
                            parties_strings.size() - 1));
        }

        parties_configuration.at(party_id) = std::make_pair(host, port);
    }

    encrypto::motion::communication::TcpSetupHelper helper(my_id, parties_configuration);
    auto communication_layer =
        std::make_unique<encrypto::motion::communication::CommunicationLayer>(
            my_id, helper.SetupConnections());
    auto party = std::make_unique<encrypto::motion::Party>(std::move(communication_layer));
    auto configuration = party->GetConfiguration();
    configuration->SetOnlineAfterSetup(true);
    return party;
}

// Helper function for generating output
template <typename T>
T to_output(const T &out)
{
    return out.Out();
}

// Helper function for generating output
template <typename T>
std::vector<T> to_output(const std::vector<T> &out)
{
    std::vector<T> output;
    for (const auto &v : out) {
        output.push_back(to_output(v));
    }
    return output;
}

int main(const int argc, const char *const argv[])
{
    auto user_options = parse_options(argc, argv);
    if (user_options["help"].as<bool>()) {
        return 0;
    }

    encrypto::motion::PartyPointer party = CreateParty(user_options);

    // clang-format off
    {%- for param in params %}
        {%- if not param.is_shared %}
            {{param.cpp_type}} {{param.name}} = user_options["{{param.name}}"].as<{{param.cpp_type}}>();
        {%- else %}
            {{param.cpp_type}} {{param.name}};
            {%- if param.dims == 0 %}
                {{param.name}} = party->In<{{protocol}}>(encrypto::motion::ToInput(user_options["{{param.name}}"].as<{{param.plaintext_cpp_type}}>()), {{param.party_idx}} % 2);
            {%- else %}
                for (const std::uint32_t value : user_options["{{param.name}}"].as<std::vector<std::uint32_t>>()) {
                    {{param.name}}.push_back(party->In<{{protocol}}>(encrypto::motion::ToInput(value), {{param.party_idx}} % 2));
                }
            {%-endif%}
        {%- endif %}
    {% endfor %} //clang-format on

    auto circuit_gen_start = std::chrono::steady_clock::now();
    auto output = {{function_name}}<{{protocol}}>(party, {{params | map(attribute = "name") | join(", ")}});
    auto circuit_gen_end = std::chrono::steady_clock::now();
    auto circuit_gen_time = std::chrono::duration_cast<std::chrono::milliseconds>(circuit_gen_end - circuit_gen_start).count();

    {%- if (outputs|count) == 1 %}
        auto out0 = to_output(output);
    {%- else %}
        {%- for idx in range(outputs | count) %}
            auto out{{idx}} = to_output(std::get<{{idx}}>(output));
        {%- endfor -%}
    {%- endif %}

    party->Run();

    party->Finish();

    encrypto::motion::AccumulatedRunTimeStatistics accumulated_statistics;
    accumulated_statistics.Add(party->GetBackend()->GetRunTimeStatistics().front());

    encrypto::motion::AccumulatedCommunicationStatistics accumulated_communication_statistics;
    accumulated_communication_statistics.Add(
        party->GetBackend()->GetCommunicationLayer().GetTransportStatistics());

    std::cerr << encrypto::motion::PrintStatistics("{{ benchmark_name }}", accumulated_statistics,
                                                   accumulated_communication_statistics)
              << std::endl;

    std::cout
    {%- if (outputs|count) > 1 -%} << "(" {%- endif -%}

    {%- for idx in range(outputs|count) %}
        {%- if idx > 0 and (outputs|count) > 1 %}
            << ", "
        {%- endif %}
        << out{{idx}}
    {%- endfor %}

    {%- if(outputs|count) > 1 -%} << ")" {%- endif -%}
    << std::endl;

    std::cout << collect_stats(party->GetBackend());
    std::cout << "circuit_gen_time: " << circuit_gen_time << std::endl;

    return 0;
}

// vim: set ft=cpp :

// Emacs:
// Local Variables:
// mode: cpp
// End:
